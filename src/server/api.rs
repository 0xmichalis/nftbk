use axum::http::{header, HeaderMap, StatusCode};
use axum::response::IntoResponse;
use axum::Json;
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Debug, Serialize, Deserialize, Clone, ToSchema)]
pub struct Tokens {
    /// The blockchain identifier (ethereum, polygon, tezos, base, arbitrum)
    #[schema(example = "ethereum")]
    pub chain: String,
    /// List of NFT token identifiers/contract addresses
    /// The tokens are formatted as `contract_address:token_id` (e.g., `0x1234567890123456789012345678901234567890:1`)
    #[schema(example = json!(["0x1234567890123456789012345678901234567890:1", "0x1234567890123456789012345678901234567890:2"]))]
    pub tokens: Vec<String>,
}

#[derive(Debug, Serialize, Deserialize, Clone, ToSchema)]
pub struct BackupRequest {
    /// List of tokens to backup, organized by blockchain
    pub tokens: Vec<Tokens>,
    /// When true, pin downloaded assets to configured IPFS provider(s)
    #[serde(default)]
    pub pin_on_ipfs: bool,
    /// When true, create an archive of downloaded assets; when false, skip archiving
    #[serde(default = "default_true")]
    pub create_archive: bool,
}

fn default_true() -> bool {
    true
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct BackupResponse {
    /// Unique identifier for the backup task
    pub task_id: String,
}

#[derive(Debug, Serialize, Deserialize, ToSchema, Clone)]
pub struct SubresourceStatus {
    /// Subresource status
    #[schema(example = "done")]
    pub status: Option<String>,
    /// Fatal error for the subresource
    pub fatal_error: Option<String>,
    /// Aggregated non-fatal error log for the subresource
    pub error_log: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct StatusResponse {
    /// Paginated tokens for this task (current page)
    pub tokens: Vec<Tokens>,
    /// Total number of tokens for this task (for pagination)
    pub total_tokens: u32,
    /// Current page number
    pub page: u32,
    /// Page size
    pub limit: u32,
    /// Archive subresource status/errors
    pub archive: SubresourceStatus,
    /// IPFS subresource status/errors
    pub ipfs: SubresourceStatus,
}

// RFC 7807 problem+json error shape
#[derive(Debug, Serialize, Deserialize, ToSchema)]
pub struct ApiProblem {
    /// A URI reference that identifies the problem type
    #[serde(default = "default_problem_type")]
    #[schema(example = "about:blank")]
    pub r#type: String,
    /// A short, human-readable summary of the problem type
    #[schema(example = "Bad Request")]
    pub title: String,
    /// The HTTP status code generated by the origin server for this occurrence of the problem
    #[schema(example = 400, minimum = 100, maximum = 599)]
    pub status: u16,
    /// A human-readable explanation specific to this occurrence of the problem
    #[serde(skip_serializing_if = "Option::is_none")]
    #[schema(example = "The request body is invalid")]
    pub detail: Option<String>,
    /// A URI reference that identifies the specific occurrence of the problem
    #[serde(skip_serializing_if = "Option::is_none")]
    #[schema(example = "/v1/backups")]
    pub instance: Option<String>,
}

fn default_problem_type() -> String {
    "about:blank".to_string()
}

impl ApiProblem {
    pub fn new(status: StatusCode, detail: Option<String>, instance: Option<String>) -> Self {
        let title = status.canonical_reason().unwrap_or("Error").to_string();
        Self {
            r#type: default_problem_type(),
            title,
            status: status.as_u16(),
            detail,
            instance,
        }
    }
    pub fn new_with_title(
        status: StatusCode,
        title: &str,
        detail: Option<String>,
        instance: Option<String>,
    ) -> Self {
        Self {
            r#type: default_problem_type(),
            title: title.to_string(),
            status: status.as_u16(),
            detail,
            instance,
        }
    }
}

/// Responder that serializes an `ApiProblem` with `application/problem+json` content type
pub struct ProblemJson(pub ApiProblem);

impl ProblemJson {
    pub fn from_status(
        status: StatusCode,
        detail: Option<String>,
        instance: Option<String>,
    ) -> Self {
        Self(ApiProblem::new(status, detail, instance))
    }
}

impl IntoResponse for ProblemJson {
    fn into_response(self) -> axum::response::Response {
        let mut headers = HeaderMap::new();
        headers.insert(
            header::CONTENT_TYPE,
            header::HeaderValue::from_static("application/problem+json"),
        );
        let status =
            StatusCode::from_u16(self.0.status).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);
        (status, headers, Json(self.0)).into_response()
    }
}

#[cfg(test)]
mod api_problem_tests {
    use super::ApiProblem;
    use axum::http::StatusCode;

    #[test]
    fn derives_title_from_status() {
        let p = ApiProblem::new(
            StatusCode::BAD_REQUEST,
            Some("detail".to_string()),
            Some("/v1/x".to_string()),
        );
        assert_eq!(p.title, "Bad Request");
        assert_eq!(p.status, 400);
        assert_eq!(p.r#type, "about:blank");
        assert_eq!(p.instance.as_deref(), Some("/v1/x"));
        assert_eq!(p.detail.as_deref(), Some("detail"));
    }

    #[test]
    fn allows_custom_title() {
        let p = ApiProblem::new_with_title(StatusCode::NOT_FOUND, "Resource Missing", None, None);
        assert_eq!(p.title, "Resource Missing");
        assert_eq!(p.status, 404);
    }

    #[test]
    fn serializes_and_deserializes() {
        let p = ApiProblem::new(
            StatusCode::UNAUTHORIZED,
            Some("auth missing".to_string()),
            Some("/v1/secure".to_string()),
        );
        let json = serde_json::to_string(&p).unwrap();
        let back: ApiProblem = serde_json::from_str(&json).unwrap();
        assert_eq!(back.title, p.title);
        assert_eq!(back.status, p.status);
        assert_eq!(back.instance, p.instance);
        assert_eq!(back.detail, p.detail);
    }
}
